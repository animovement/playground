<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>animovement Playground</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">
  
  <!-- CodeMirror 5 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/r/r.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>

  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #242424;
      --bg-tertiary: #2d2d2d;
      --text-primary: #e8e6e3;
      --text-secondary: #a8a5a0;
      --text-muted: #6b6965;
      --accent: #7eb8da;
      --accent-dim: #5a8ba8;
      --success: #8fbc8f;
      --error: #cd6155;
      --border: #3a3a3a;
      --font-mono: 'JetBrains Mono', monospace;
      --font-serif: 'Source Serif 4', Georgia, serif;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font-mono);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
    }

    .container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 1rem;
      gap: 0.75rem;
    }

    header {
      flex-shrink: 0;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    h1 {
      font-family: var(--font-serif);
      font-weight: 600;
      font-size: 1.35rem;
      letter-spacing: -0.02em;
    }

    h1 span {
      color: var(--accent);
    }

    .status {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: background 0.3s ease;
    }

    .status-dot.loading {
      background: var(--accent);
      animation: pulse 1.5s ease-in-out infinite;
    }

    .status-dot.ready {
      background: var(--success);
    }

    .status-dot.error {
      background: var(--error);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .keybindings-hint {
      font-size: 0.6rem;
      color: var(--text-muted);
      margin-top: 0.2rem;
    }

    .keybindings-hint kbd {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 0.1rem 0.3rem;
      font-family: var(--font-mono);
      font-size: 0.55rem;
    }

    /* Main layout */
    .main-layout {
      flex: 1;
      display: flex;
      min-height: 0;
      gap: 0;
    }

    .left-pane {
      display: flex;
      flex-direction: column;
      min-width: 200px;
      gap: 0;
    }

    .right-pane {
      display: flex;
      flex-direction: column;
      min-width: 200px;
      gap: 0;
    }

    /* Resize handles */
    .resize-handle-h {
      width: 6px;
      cursor: col-resize;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .resize-handle-h:hover,
    .resize-handle-h.dragging {
      background: var(--border);
    }

    .resize-handle-h::after {
      content: '';
      width: 2px;
      height: 40px;
      background: var(--border);
      border-radius: 1px;
    }

    .resize-handle-v {
      height: 6px;
      cursor: row-resize;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .resize-handle-v:hover,
    .resize-handle-v.dragging {
      background: var(--border);
    }

    .resize-handle-v::after {
      content: '';
      height: 2px;
      width: 40px;
      background: var(--border);
      border-radius: 1px;
    }

    /* Panels */
    .panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .panel-header {
      flex-shrink: 0;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-tertiary);
    }

    .panel-title {
      font-size: 0.65rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
    }

    .panel-hint {
      font-size: 0.6rem;
      color: var(--text-muted);
    }

    .panel-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .panel-btn {
      font-family: var(--font-mono);
      font-size: 0.65rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      border-radius: 3px;
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .panel-btn:hover:not(:disabled) {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .panel-btn.primary {
      background: var(--accent);
      color: var(--bg-primary);
      border-color: var(--accent);
    }

    .panel-btn.primary:hover:not(:disabled) {
      background: var(--accent-dim);
      border-color: var(--accent-dim);
    }

    .panel-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Editor */
    .editor-wrapper {
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .CodeMirror {
      height: 100%;
      font-family: var(--font-mono);
      font-size: 0.8rem;
      line-height: 1.6;
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .CodeMirror-gutters {
      background: var(--bg-tertiary);
      border-right: 1px solid var(--border);
    }

    .CodeMirror-linenumber {
      color: var(--text-muted);
      font-size: 0.7rem;
    }

    .CodeMirror-cursor {
      border-left: 2px solid var(--accent);
    }

    .CodeMirror-selected {
      background: rgba(126, 184, 218, 0.25) !important;
    }

    .CodeMirror-focused .CodeMirror-selected {
      background: rgba(126, 184, 218, 0.3) !important;
    }

    .CodeMirror-activeline-background {
      background: rgba(126, 184, 218, 0.05);
    }

    .CodeMirror-matchingbracket {
      color: var(--accent) !important;
      background: rgba(126, 184, 218, 0.3);
    }

    /* R syntax highlighting */
    .cm-keyword { color: #c586c0; }
    .cm-atom { color: #569cd6; }
    .cm-number { color: #b5cea8; }
    .cm-def { color: #dcdcaa; }
    .cm-variable { color: #9cdcfe; }
    .cm-variable-2 { color: #9cdcfe; }
    .cm-variable-3 { color: #4ec9b0; }
    .cm-property { color: #9cdcfe; }
    .cm-operator { color: #d4d4d4; }
    .cm-comment { color: #6a9955; font-style: italic; }
    .cm-string { color: #ce9178; }
    .cm-string-2 { color: #ce9178; }
    .cm-builtin { color: #dcdcaa; }

    /* Console */
    .console-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .console-output {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      min-height: 0;
    }

    .console-line {
      white-space: pre-wrap;
      word-break: break-word;
      margin-bottom: 0.15rem;
    }

    .console-line.stdout { color: var(--text-primary); }
    .console-line.stderr { color: var(--error); }
    .console-line.command { color: var(--accent); }
    .console-line.system { color: var(--text-muted); font-style: italic; }

    /* Console input with CodeMirror */
    .console-input-wrapper {
      flex-shrink: 0;
      display: flex;
      align-items: stretch;
      border-top: 1px solid var(--border);
      background: var(--bg-tertiary);
    }

    .console-prompt {
      padding: 0.4rem 0.5rem;
      color: var(--accent);
      font-size: 0.75rem;
      user-select: none;
      display: flex;
      align-items: center;
    }

    .console-input-cm {
      flex: 1;
      min-height: 24px;
    }

    .console-input-cm .CodeMirror {
      height: auto;
      min-height: 24px;
      max-height: 100px;
      background: var(--bg-tertiary);
      font-size: 0.75rem;
      line-height: 1.5;
    }

    .console-input-cm .CodeMirror-scroll {
      min-height: 24px;
    }

    .console-input-cm .CodeMirror-lines {
      padding: 4px 0;
    }

    .console-input-cm .CodeMirror-gutters {
      display: none;
    }

    .console-input-cm .CodeMirror-cursor {
      border-left: 2px solid var(--accent);
    }

    /* Tab navigation for right pane */
    .tab-nav {
      display: flex;
      border-bottom: 1px solid var(--border);
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }

    .tab-btn {
      font-family: var(--font-mono);
      font-size: 0.65rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
    }

    .tab-btn.active {
      color: var(--accent);
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
    }

    .tab-content {
      flex: 1;
      display: none;
      flex-direction: column;
      min-height: 0;
    }

    .tab-content.active {
      display: flex;
    }

    /* Session pane (Variables + Plots) */
    .session-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .session-section {
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .session-section-header {
      flex-shrink: 0;
      padding: 0.4rem 0.75rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-secondary);
    }

    .session-section-title {
      font-size: 0.6rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    /* Variables section */
    .variables-wrapper {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      min-height: 0;
    }

    .variables-empty {
      color: var(--text-muted);
      font-size: 0.7rem;
      font-style: italic;
    }

    /* Help pane */
    .help-wrapper {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
      background: var(--bg-secondary);
    }

    .help-pre {
      margin: 0;
      padding: 0.75rem;
      font-family: var(--font-mono);
      font-size: 0.75rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--text-primary);
    }

    .help-empty {
      color: var(--text-muted);
      font-style: italic;
      padding: 0.75rem;
    }

    .help-header-line {
      display: block;
      margin-bottom: 0.5rem;
    }

    .help-func-name {
      color: var(--accent);
      font-weight: 600;
    }

    .help-pkg-name {
      color: var(--text-muted);
    }

    .help-r-doc {
      color: var(--text-muted);
    }

    .help-underline {
      text-decoration: underline;
      color: var(--text-primary);
    }

    .help-link {
      color: var(--accent-dim);
      text-decoration: none;
    }

    .help-link:hover {
      color: var(--accent);
      text-decoration: underline;
    }

    .help-code-inline {
      background: var(--bg-tertiary);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.9em;
    }

    /* Plots carousel */
    .plots-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .plot-carousel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      padding: 0.5rem;
      position: relative;
    }

    .plot-container {
      max-width: 100%;
      max-height: 100%;
      background: #ffffff;
      border-radius: 4px;
      padding: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .plot-container img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .plots-empty {
      color: var(--text-muted);
      font-size: 0.7rem;
      font-style: italic;
    }

    .plot-nav {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      padding: 0.5rem;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .plot-nav-btn {
      font-family: var(--font-mono);
      font-size: 0.9rem;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .plot-nav-btn:hover:not(:disabled) {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .plot-nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .plot-counter {
      font-size: 0.7rem;
      color: var(--text-muted);
      min-width: 60px;
      text-align: center;
    }

    footer {
      flex-shrink: 0;
      padding-top: 0.5rem;
      border-top: 1px solid var(--border);
      font-size: 0.65rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    footer a {
      color: var(--accent-dim);
      text-decoration: none;
    }

    footer a:hover {
      color: var(--accent);
    }

    /* Disable selection during resize */
    body.resizing {
      user-select: none;
      cursor: col-resize;
    }

    body.resizing-v {
      user-select: none;
      cursor: row-resize;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1><span>animovement</span> playground</h1>
        <div class="keybindings-hint">
          <kbd>Cmd/Ctrl+Enter</kbd> Run selection or line &nbsp;
          <kbd>Cmd/Ctrl+Shift+M</kbd> |&gt; &nbsp;
          <kbd>Alt+-</kbd> &lt;-
        </div>
      </div>
      <div class="status">
        <span class="status-dot loading" id="statusDot"></span>
        <span id="statusText">Initializing WebR...</span>
      </div>
    </header>

    <div class="main-layout">
      <div class="left-pane" id="leftPane" style="flex: 1 1 60%;">
        <!-- Editor Panel -->
        <div class="panel" id="editorPanel" style="flex: 1 1 60%;">
          <div class="panel-header">
            <span class="panel-title">Script</span>
            <div class="panel-actions">
              <button class="panel-btn" id="runLineBtn" disabled title="Run current expression (Cmd/Ctrl+Enter)">Run line</button>
              <button class="panel-btn primary" id="runScriptBtn" disabled title="Run entire script">Run script</button>
            </div>
          </div>
          <div class="editor-wrapper">
            <textarea id="editor"># Write your R code here
# Select code and press Cmd/Ctrl+Enter to run selection
# Or run current line if nothing selected

# Try: ?example_aniframe for help documentation

</textarea>
          </div>
        </div>

        <!-- Vertical resize handle -->
        <div class="resize-handle-v" id="resizeV"></div>

        <!-- Console Panel -->
        <div class="panel" id="consolePanel" style="flex: 1 1 40%;">
          <div class="panel-header">
            <span class="panel-title">Console</span>
            <div class="panel-actions">
              <button class="panel-btn" id="clearConsoleBtn">Clear</button>
            </div>
          </div>
          <div class="console-wrapper">
            <div class="console-output" id="consoleOutput">
              <div class="console-line system">Waiting for WebR to initialize...</div>
            </div>
            <div class="console-input-wrapper">
              <span class="console-prompt">&gt;</span>
              <div class="console-input-cm" id="consoleInputCm"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Horizontal resize handle -->
      <div class="resize-handle-h" id="resizeH"></div>

      <!-- Right pane with tabs -->
      <div class="right-pane" id="rightPane" style="flex: 1 1 40%;">
        <div class="panel" style="flex: 1; display: flex; flex-direction: column;">
          <!-- Tab navigation -->
          <div class="tab-nav">
            <button class="tab-btn active" id="tabSession" data-tab="session">Session</button>
            <button class="tab-btn" id="tabHelp" data-tab="help">Help</button>
          </div>

          <!-- Session tab content -->
          <div class="tab-content active" id="sessionContent">
            <div class="session-pane">
              <!-- Variables section -->
              <div class="session-section" id="variablesSection" style="flex: 1 1 40%;">
                <div class="session-section-header">
                  <span class="session-section-title">Variables</span>
                </div>
                <div class="variables-wrapper" id="variablesContent">
                  <span class="variables-empty">No variables in environment</span>
                </div>
              </div>

              <!-- Vertical resize handle for session pane -->
              <div class="resize-handle-v" id="resizeVSession"></div>

              <!-- Plots section -->
              <div class="session-section" id="plotsSection" style="flex: 1 1 60%;">
                <div class="session-section-header">
                  <span class="session-section-title">Plots</span>
                  <div class="panel-actions">
                    <button class="panel-btn" id="clearPlotsBtn">Clear</button>
                  </div>
                </div>
                <div class="plots-wrapper">
                  <div class="plot-carousel" id="plotCarousel">
                    <span class="plots-empty" id="plotsEmpty">Plots will appear here</span>
                    <div class="plot-container" id="plotContainer" style="display: none;">
                      <img id="plotImage" src="" alt="Plot">
                    </div>
                  </div>
                  <div class="plot-nav" id="plotNav" style="display: none;">
                    <button class="plot-nav-btn" id="plotPrev" disabled>&larr;</button>
                    <span class="plot-counter" id="plotCounter">1 / 1</span>
                    <button class="plot-nav-btn" id="plotNext" disabled>&rarr;</button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Help tab content -->
          <div class="tab-content" id="helpContent">
            <div class="panel-header" style="border-top: none;">
              <span class="panel-hint" id="helpTopic"></span>
              <div class="panel-actions">
                <button class="panel-btn" id="clearHelpBtn">Clear</button>
              </div>
            </div>
            <div class="help-wrapper" id="helpWrapper">
              <span class="help-empty">Run ?topic or help(topic) to view documentation</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <span>Powered by <a href="https://docs.r-wasm.org/webr/" target="_blank">WebR</a></span>
      <span>Packages from <a href="https://animovement.r-universe.dev" target="_blank">animovement.r-universe.dev</a></span>
    </footer>
  </div>

  <script type="module">
import { WebR } from 'https://webr.r-wasm.org/latest/webr.mjs';

// ===== State =====

let webR = null;
let editor = null;
let consoleInput = null;
let isRunning = false;
let commandHistory = [];
let historyIndex = -1;
let plotImages = [];
let currentPlotIndex = 0;
let activeTab = 'session';

// ===== DOM Ready Check =====

function getElement(id) {
  const el = document.getElementById(id);
  if (!el) console.error(`Element not found: ${id}`);
  return el;
}

// ===== ANSI Styling =====
function ansiToHtml(str) {
  const ansiColors = {
    '30': '#000000', '31': '#cd6155', '32': '#8fbc8f', '33': '#f0c674',
    '34': '#7eb8da', '35': '#c586c0', '36': '#4ec9b0', '37': '#e8e6e3',
    '38;5;33': '#7eb8da', '38;5;198': '#c586c0',
    '39': null, // default foreground
    '1': 'bold', '22': 'unbold'
  };
  
  let result = '';
  let currentStyles = { color: null, bold: false };
  let i = 0;
  
  while (i < str.length) {
    if (str[i] === '\x1B' && str[i + 1] === '[') {
      const endIdx = str.indexOf('m', i);
      if (endIdx !== -1) {
        const code = str.slice(i + 2, endIdx);
        
        if (code === '1') {
          currentStyles.bold = true;
        } else if (code === '22') {
          currentStyles.bold = false;
        } else if (code === '39' || code === '0') {
          currentStyles.color = null;
          currentStyles.bold = false;
        } else if (ansiColors[code]) {
          currentStyles.color = ansiColors[code];
        }
        
        i = endIdx + 1;
        continue;
      }
    }
    
    // Find next escape or end of string
    let nextEscape = str.indexOf('\x1B', i);
    if (nextEscape === -1) nextEscape = str.length;
    
    const text = str.slice(i, nextEscape);
    if (text) {
      const styles = [];
      if (currentStyles.color) styles.push(`color:${currentStyles.color}`);
      if (currentStyles.bold) styles.push('font-weight:600');
      
      if (styles.length > 0) {
        result += `<span style="${styles.join(';')}">${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>`;
      } else {
        result += text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
    }
    
    i = nextEscape;
  }
  
  return result;
}

// ===== Editor Setup =====

function isLineContinuation(line) {
  const trimmed = line.trimEnd();
  // Line continues if it ends with: pipe, +, comma, opening bracket, or operator
  return /(\|>|%>%|\+|,|\{|\(|\[|&&|\|\||&|\\)$/.test(trimmed);
}

function startsWithContinuation(line) {
  // Line is a continuation if it starts with pipe or +
  return /^\s*(\|>|%>%|\+)/.test(line);
}

function startsWithClosingBracket(line) {
  return /^\s*[\)\]\}]/.test(line);
}

function countBrackets(text) {
  let parens = 0, brackets = 0, braces = 0;
  let inString = false;
  let stringChar = '';
  
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    const prev = i > 0 ? text[i - 1] : '';
    
    if (inString) {
      if (ch === stringChar && prev !== '\\') inString = false;
      continue;
    }
    
    if (ch === '"' || ch === "'") {
      inString = true;
      stringChar = ch;
    } else if (ch === '(') parens++;
    else if (ch === ')') parens--;
    else if (ch === '[') brackets++;
    else if (ch === ']') brackets--;
    else if (ch === '{') braces++;
    else if (ch === '}') braces--;
  }
  
  return { parens, brackets, braces, inString };
}

function getExpressionStart(cm, fromLine) {
  let exprStart = fromLine;
  
  for (let i = fromLine; i > 0; i--) {
    const currentLine = cm.getLine(i);
    const checkPrevLine = cm.getLine(i - 1);
    
    if (startsWithContinuation(currentLine) || 
        startsWithClosingBracket(currentLine) ||
        isLineContinuation(checkPrevLine)) {
      exprStart = i - 1;
      continue;
    }
    
    // Check bracket balance of previous line
    const prevCounts = countBrackets(checkPrevLine);
    if (prevCounts.parens > 0 || prevCounts.brackets > 0 || prevCounts.braces > 0) {
      exprStart = i - 1;
      continue;
    }
    
    break;
  }
  
  return exprStart;
}

function getConnectedLines(cm, startLine) {
  const totalLines = cm.lineCount();
  
  // Search backwards for the start of this expression
  let firstLine = getExpressionStart(cm, startLine);
  
  // Now check bracket balance from firstLine to find the true end
  let lastLine = firstLine;
  let cumulativeCode = '';
  
  for (let i = firstLine; i < totalLines; i++) {
    const line = cm.getLine(i);
    cumulativeCode += (i > firstLine ? '\n' : '') + line;
    
    const counts = countBrackets(cumulativeCode);
    const bracketsBalanced = counts.parens === 0 && counts.brackets === 0 && 
                              counts.braces === 0 && !counts.inString;
    
    lastLine = i;
    
    // If brackets are balanced, check if line continues with pipe/+ or next line starts with continuation
    if (bracketsBalanced) {
      if (isLineContinuation(line)) {
        // Line ends with pipe/+, continue
        continue;
      }
      
      // Check if next line starts with continuation
      if (i + 1 < totalLines && startsWithContinuation(cm.getLine(i + 1))) {
        continue;
      }
      
      // We're done
      break;
    }
  }
  
  // Collect the lines
  const lines = [];
  for (let i = firstLine; i <= lastLine; i++) {
    lines.push(cm.getLine(i));
  }
  
  return {
    code: lines.join('\n'),
    firstLine,
    lastLine
  };
}

function rAutoIndent(cm) {
  const cursor = cm.getCursor();
  const line = cursor.line;
  
  if (line === 0) return '';
  
  const prevLine = cm.getLine(line - 1);
  const prevIndent = prevLine.match(/^\s*/)[0];
  
  // Find expression start
  const exprStart = getExpressionStart(cm, line - 1);
  
  // Calculate bracket balance up to end of previous line
  let cumulativeCode = '';
  for (let i = exprStart; i < line; i++) {
    cumulativeCode += (i > exprStart ? '\n' : '') + cm.getLine(i);
  }
  
  const counts = countBrackets(cumulativeCode);
  const openBracketCount = counts.parens + counts.brackets + counts.braces;
  
  // Get the base indent (indent of the first line of expression)
  const baseIndent = cm.getLine(exprStart).match(/^\s*/)[0];
  
  // If we have open brackets, indent one level from base
  if (openBracketCount > 0) {
    return baseIndent + '  ';
  }
  
  // If previous line ends with pipe/+ but brackets are balanced,
  // indent one level from base (not cumulative)
  if (isLineContinuation(prevLine)) {
    return baseIndent + '  ';
  }
  
  // Expression is complete, return to base indent
  return baseIndent;
}

function initEditor(initialCode) {
  const editorTextarea = getElement('editor');
  if (!editorTextarea) return;
  
  editor = CodeMirror.fromTextArea(editorTextarea, {
    mode: 'r',
    theme: 'default',
    lineNumbers: true,
    matchBrackets: true,
    autoCloseBrackets: true,
    styleActiveLine: true,
    indentUnit: 2,
    tabSize: 2,
    indentWithTabs: false,
    extraKeys: {
      'Cmd-Enter': runFromEditor,
      'Ctrl-Enter': runFromEditor,
      'Shift-Cmd-M': (cm) => cm.replaceSelection(' |> '),
      'Shift-Ctrl-M': (cm) => cm.replaceSelection(' |> '),
      'Alt--': (cm) => cm.replaceSelection(' <- '),
      'Tab': (cm) => {
        if (cm.somethingSelected()) {
          cm.indentSelection('add');
        } else {
          cm.replaceSelection('  ', 'end');
        }
      },
      'Enter': (cm) => {
        const cursor = cm.getCursor();
        const line = cm.getLine(cursor.line);

        // If current line is blank, just add a newline with same (no) indent
        if (line.trim() === '') {
          cm.replaceSelection('\n');
          return;
        }

        const beforeCursor = line.slice(0, cursor.ch);
        const afterCursor = line.slice(cursor.ch);
        
        // Check if we're between opening and closing brackets
        const lastCharBefore = beforeCursor.trimEnd().slice(-1);
        const firstCharAfter = afterCursor.trimStart()[0];
        const betweenBrackets = 
          (lastCharBefore === '(' && firstCharAfter === ')') ||
          (lastCharBefore === '[' && firstCharAfter === ']') ||
          (lastCharBefore === '{' && firstCharAfter === '}');
        
        if (betweenBrackets) {
          // Insert newline with indent, then another newline with base indent for closing bracket
          const baseIndent = line.match(/^\s*/)[0];
          const newIndent = baseIndent + '  ';
          cm.replaceSelection('\n' + newIndent + '\n' + baseIndent);
          // Move cursor to the indented line
          cm.setCursor(cursor.line + 1, newIndent.length);
        } else {
          const indent = rAutoIndent(cm);
          cm.replaceSelection('\n' + indent);
        }
      }
    }
  });

  if (initialCode) {
    editor.setValue(initialCode);
  }
}

function initConsoleInput() {
  const consoleInputCm = getElement('consoleInputCm');
  if (!consoleInputCm) return;
  
  consoleInput = CodeMirror(consoleInputCm, {
    mode: 'r',
    theme: 'default',
    lineNumbers: false,
    matchBrackets: true,
    autoCloseBrackets: true,
    scrollbarStyle: 'null',
    viewportMargin: Infinity,
    extraKeys: {
      'Enter': handleConsoleEnter,
      'Up': handleConsoleUp,
      'Down': handleConsoleDown,
      'Shift-Cmd-M': (cm) => cm.replaceSelection(' |> '),
      'Shift-Ctrl-M': (cm) => cm.replaceSelection(' |> '),
      'Alt--': (cm) => cm.replaceSelection(' <- ')
    }
  });
}

function handleConsoleEnter() {
  const code = consoleInput.getValue().trim();
  if (code) {
    commandHistory.unshift(code);
    historyIndex = -1;
    consoleInput.setValue('');
    runCode(code);
  }
}

function handleConsoleUp() {
  if (historyIndex < commandHistory.length - 1) {
    historyIndex++;
    consoleInput.setValue(commandHistory[historyIndex]);
    consoleInput.setCursor(consoleInput.lineCount(), 0);
  }
}

function handleConsoleDown() {
  if (historyIndex > 0) {
    historyIndex--;
    consoleInput.setValue(commandHistory[historyIndex]);
    consoleInput.setCursor(consoleInput.lineCount(), 0);
  } else if (historyIndex === 0) {
    historyIndex = -1;
    consoleInput.setValue('');
  }
}

function runFromEditor() {
  if (!editor) return;
  
  const selection = editor.getSelection();
  let code;
  
  if (selection) {
    // Run selected text
    code = selection;
  } else {
    // Get connected lines around cursor
    const cursor = editor.getCursor();
    const connected = getConnectedLines(editor, cursor.line);
    code = connected.code;
    
    // Move cursor to line after the expression
    if (connected.lastLine < editor.lineCount() - 1) {
      editor.setCursor(connected.lastLine + 1, 0);
    }
  }
  
  if (code.trim()) {
    runCode(code.trim());
  }
}

function runScript() {
  if (!editor) return;
  
  const code = editor.getValue().trim();
  if (code) {
    runCode(code);
  }
}

// ===== Status =====

function setStatus(state, text) {
  const statusDot = getElement('statusDot');
  const statusText = getElement('statusText');
  if (statusDot) statusDot.className = 'status-dot ' + state;
  if (statusText) statusText.textContent = text;
}

// ===== Console =====

function appendConsole(text, type = 'stdout', isHtml = false) {
  const consoleOutput = getElement('consoleOutput');
  if (!consoleOutput) return;
  
  const line = document.createElement('div');
  line.className = 'console-line ' + type;
  
  if (isHtml) {
    line.innerHTML = text;
  } else {
    line.textContent = text;
  }
  
  consoleOutput.appendChild(line);
  consoleOutput.scrollTop = consoleOutput.scrollHeight;
}

function clearConsole() {
  const consoleOutput = getElement('consoleOutput');
  if (consoleOutput) consoleOutput.innerHTML = '';
}

// ===== Tabs =====

function switchTab(tabName) {
  activeTab = tabName;
  
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabName);
  });
  
  // Update tab content
  const sessionContent = getElement('sessionContent');
  const helpContent = getElement('helpContent');
  
  if (sessionContent) sessionContent.classList.toggle('active', tabName === 'session');
  if (helpContent) helpContent.classList.toggle('active', tabName === 'help');
}

// ===== Help =====

function clearHelp() {
  const helpWrapper = getElement('helpWrapper');
  const helpTopic = getElement('helpTopic');
  if (helpWrapper) helpWrapper.innerHTML = '<span class="help-empty">Run ?topic or help(topic) to view documentation</span>';
  if (helpTopic) helpTopic.textContent = '';
}

function displayHelp(topic, text) {
  const helpWrapper = getElement('helpWrapper');
  const helpTopic   = getElement('helpTopic');
  if (helpTopic) helpTopic.textContent = topic;
  if (!helpWrapper) return;

  let formatted = String(text);

  // ANSI underline → <u>
  formatted = formatted.replace(/\x1B\[4m([\s\S]*?)\x1B\[24m/g, '<u>$1</u>');
  // Strip other ANSI codes
  formatted = formatted.replace(/\x1B\[[0-9;]*m/g, '');
  // Collapse "_x_" markup
  formatted = formatted.replace(/_([A-Za-z0-9()])_/g, '$1');
  // Escape HTML
  formatted = formatted
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // Wrap headings (e.g., "DESCRIPTION:", "USAGE")
  const lines = formatted.split('\n');
  formatted = lines
    .map(line => {
      const trimmed = line.trim();
      if (!trimmed) return line;
      const isHeader = /^[A-Z][A-Za-z() ]*:?$/.test(trimmed) && trimmed.length < 50;
      return isHeader
        ? line.replace(trimmed, `<span class="help-underline">${trimmed}</span>`)
        : line;
    })
    .join('\n');

  // Inline code (single quotes, ignore simple possessives)
  formatted = formatted.replace(/'([^']+)'/g, (m, p) =>
    /^[a-z]+s$/.test(p) && !/\s/.test(p) ? m : `<span class="help-code-inline">${p}</span>`
  );

  // Bold *word*
  formatted = formatted.replace(/\*([A-Za-z][^*]*)\*/g, '<strong>$1</strong>');

  // URLs and mailto links
  formatted = formatted.replace(/(https?:\/\/[^\s&lt;]+)/g,
    '<a href="$1" target="_blank" class="help-link">$1</a>');
  formatted = formatted.replace(/(mailto:[^\s&lt;]+)/g,
    '<a href="$1" class="help-link">$1</a>');

  // First‑line package header
  formatted = formatted.replace(
    /^(\S+)(\s+)(package:\S+)(\s+)(R Documentation)/m,
    '<div class="help-header-line">' +
      '<span class="help-func-name">$1</span>$2' +
      '<span class="help-pkg-name">$3</span>$4' +
      '<span class="help-r-doc">$5</span></div>'
  );

  helpWrapper.innerHTML = `<pre class="help-pre">${formatted}</pre>`;
  switchTab('help');
}

function isHelpRequest(code) {
  // Match ?topic, ?pkg::topic, ?topic(), help(topic), help("topic"), help(pkg::topic), etc.
  const questionMatch = code.match(/^\?(.+)$/);
  if (questionMatch) {
    // Clean up: remove parentheses and whitespace
    return questionMatch[1].trim().replace(/\(\)$/, '');
  }
  
  const helpMatch = code.match(/^help\(["']?([^"')]+)["']?\)$/);
  if (helpMatch) {
    return helpMatch[1].trim();
  }
  
  return null;
}

async function getHelp(topic) {
  if (!webR) return;
  
  try {
    // Check if topic includes package (pkg::func)
    const pkgMatch = topic.match(/^([^:]+)::(.+)$/);
    
    let rCode;
    if (pkgMatch) {
      const pkg = pkgMatch[1];
      const func = pkgMatch[2];
      rCode = `
        tryCatch({
          h <- help("${func}", package = "${pkg}")
          if (length(h) > 0) {
            helpfile <- utils:::.getHelpFile(h)
            txt <- capture.output(tools::Rd2txt(helpfile, out = stdout(), package = "${pkg}"))
            paste(txt, collapse = "\\n")
          } else {
            "No documentation found for '${topic}'"
          }
        }, error = function(e) {
          paste("Error:", e$message)
        })
      `;
    } else {
      rCode = `
        tryCatch({
          # Use help.search to find the topic, then get specific help
          hs <- help.search("^${topic}$", fields = "name")
          matches <- hs$matches
          
          if (nrow(matches) == 0) {
            "No documentation found for '${topic}'"
          } else {
            # Get help from the first matching package
            pkg <- matches$Package[1]
            h <- help("${topic}", package = (pkg))
            if (length(h) > 0) {
              helpfile <- utils:::.getHelpFile(h)
              txt <- capture.output(tools::Rd2txt(helpfile, out = stdout(), package = pkg))
              paste(txt, collapse = "\\n")
            } else {
              "No documentation found for '${topic}'"
            }
          }
        }, error = function(e) {
          paste("Error:", e$message)
        })
      `;
    }
    
    const result = await webR.evalRString(rCode);
    displayHelp(topic, result);
  } catch (error) {
    displayHelp(topic, `Error getting help: ${error.message}`);
  }
}

// ===== Plots =====

async function imageBitmapToDataUrl(bitmap) {
  const canvas = document.createElement('canvas');
  canvas.width = bitmap.width;
  canvas.height = bitmap.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(bitmap, 0, 0);
  return canvas.toDataURL('image/png');
}

function updatePlotDisplay() {
  const plotsEmpty = getElement('plotsEmpty');
  const plotContainer = getElement('plotContainer');
  const plotNav = getElement('plotNav');
  const plotImage = getElement('plotImage');
  const plotCounter = getElement('plotCounter');
  const plotPrev = getElement('plotPrev');
  const plotNext = getElement('plotNext');
  
  if (plotImages.length === 0) {
    if (plotsEmpty) plotsEmpty.style.display = '';
    if (plotContainer) plotContainer.style.display = 'none';
    if (plotNav) plotNav.style.display = 'none';
    return;
  }

  if (plotsEmpty) plotsEmpty.style.display = 'none';
  if (plotContainer) plotContainer.style.display = '';
  if (plotNav) plotNav.style.display = 'flex';

  if (plotImage) plotImage.src = plotImages[currentPlotIndex];
  if (plotCounter) plotCounter.textContent = `${currentPlotIndex + 1} / ${plotImages.length}`;

  if (plotPrev) plotPrev.disabled = currentPlotIndex === 0;
  if (plotNext) plotNext.disabled = currentPlotIndex === plotImages.length - 1;
}

async function addPlot(imageData) {
  let dataUrl;
  
  if (imageData instanceof ImageBitmap) {
    dataUrl = await imageBitmapToDataUrl(imageData);
  } else if (typeof imageData === 'string') {
    dataUrl = imageData;
  } else if (imageData instanceof Blob) {
    dataUrl = URL.createObjectURL(imageData);
  }

  plotImages.push(dataUrl);
  currentPlotIndex = plotImages.length - 1;
  updatePlotDisplay();
}

function clearPlots() {
  plotImages = [];
  currentPlotIndex = 0;
  updatePlotDisplay();
}

// ===== WebR =====

async function initWebR() {
  try {
    setStatus('loading', 'Initializing WebR...');
    
    webR = new WebR();
    await webR.init();

    setStatus('loading', 'Configuring repositories...');
    
    await webR.evalR(`
      options(
        repos = c(
          animovement = "https://animovement.r-universe.dev",
          CRAN = "https://repo.r-wasm.org"
        ),
        webr.show_menu = FALSE
      )
    `);

    setStatus('loading', 'Installing animovement...');
    clearConsole();
    appendConsole('Installing animovement package...', 'system');

    await webR.evalR(`
      webr::install("animovement", repos = c(
        "https://animovement.r-universe.dev",
        "https://repo.r-wasm.org"
      ))
    `);

    appendConsole('', 'system');
    
// Run library(animovement) and show it in the console
    appendConsole('> library(animovement)', 'command');
    
    const shelter = await new webR.Shelter();
    try {
      const result = await shelter.captureR('library(animovement)', {
        withAutoprint: true,
        captureStreams: true,
        captureConditions: false
      });
      
      // Display any output from loading the library
      for (const out of result.output) {
        if (typeof out.data !== 'string') continue;
        const htmlData = ansiToHtml(out.data);
        if (out.type === 'stdout' && out.data.trim()) {
          appendConsole(htmlData, 'stdout', true);
        } else if (out.type === 'stderr' && out.data.trim()) {
          appendConsole(htmlData, 'stderr', true);
        }
      }
    } finally {
      await shelter.purge();
    }

    appendConsole('', 'system');

    setStatus('ready', 'Ready');
    
    const runLineBtn = getElement('runLineBtn');
    const runScriptBtn = getElement('runScriptBtn');
    if (runLineBtn) runLineBtn.disabled = false;
    if (runScriptBtn) runScriptBtn.disabled = false;
    if (consoleInput) {
      consoleInput.setOption('readOnly', false);
      consoleInput.focus();
    }

  } catch (error) {
    setStatus('error', 'Initialization failed');
    appendConsole('Error: ' + error.message, 'stderr');
    console.error('WebR init error:', error);
  }
}

async function runCode(code) {
  if (isRunning || !webR || !code) return;

  // Check if this is a help request
  const helpTopicMatch = isHelpRequest(code);
  if (helpTopicMatch) {
    appendConsole('> ' + code, 'command');
    await getHelp(helpTopicMatch);
    return;
  }

  isRunning = true;
  const runLineBtn = getElement('runLineBtn');
  const runScriptBtn = getElement('runScriptBtn');
  if (runLineBtn) runLineBtn.disabled = true;
  if (runScriptBtn) runScriptBtn.disabled = true;
  if (consoleInput) consoleInput.setOption('readOnly', true);
  setStatus('loading', 'Running...');

  const lines = code.split('\n');
  lines.forEach((line, i) => {
    appendConsole((i === 0 ? '> ' : '+ ') + line, 'command');
  });

  try {
    const shelter = await new webR.Shelter();
    
    try {
      const result = await shelter.captureR(code, {
        withAutoprint: true,
        captureStreams: true,
        captureConditions: true,
        captureGraphics: {
          width: 800,
          height: 600
        }
      });

      for (const out of result.output) {
        if (out.type === 'stdout' && out.data.trim()) {
          appendConsole(out.data, 'stdout');
        } else if (out.type === 'stderr' && out.data.trim()) {
          appendConsole(out.data, 'stderr');
        } else if (out.type === 'message') {
          appendConsole(out.data, 'stderr');
        }
      }

      if (result.images && result.images.length > 0) {
        for (const img of result.images) {
          await addPlot(img);
        }
      }

    } finally {
      await shelter.purge();
    }

  } catch (error) {
    appendConsole('Error: ' + error.message, 'stderr');
  }

  isRunning = false;
  if (runLineBtn) runLineBtn.disabled = false;
  if (runScriptBtn) runScriptBtn.disabled = false;
  if (consoleInput) consoleInput.setOption('readOnly', false);
  setStatus('ready', 'Ready');
}

// ===== Resize =====

function initResize() {
  const leftPane = getElement('leftPane');
  const rightPane = getElement('rightPane');
  const editorPanel = getElement('editorPanel');
  const consolePanel = getElement('consolePanel');
  const variablesSection = getElement('variablesSection');
  const plotsSection = getElement('plotsSection');
  const resizeH = getElement('resizeH');
  const resizeV = getElement('resizeV');
  const resizeVSession = getElement('resizeVSession');

  // Horizontal resize (left/right panes)
  if (resizeH && leftPane && rightPane) {
    resizeH.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const startX = e.clientX;
      const startLeftWidth = leftPane.getBoundingClientRect().width;
      const startRightWidth = rightPane.getBoundingClientRect().width;
      
      document.body.classList.add('resizing');
      resizeH.classList.add('dragging');
      
      const onMouseMove = (e) => {
        const delta = e.clientX - startX;
        const totalWidth = startLeftWidth + startRightWidth;
        const newLeftWidth = Math.max(200, Math.min(totalWidth - 200, startLeftWidth + delta));
        const newRightWidth = totalWidth - newLeftWidth;
        
        leftPane.style.flex = `0 0 ${newLeftWidth}px`;
        rightPane.style.flex = `0 0 ${newRightWidth}px`;
      };
      
      const onMouseUp = () => {
        document.body.classList.remove('resizing');
        resizeH.classList.remove('dragging');
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        if (editor) editor.refresh();
        if (consoleInput) consoleInput.refresh();
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }

  // Vertical resize (editor/console)
  if (resizeV && editorPanel && consolePanel) {
    resizeV.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const startY = e.clientY;
      const startEditorHeight = editorPanel.getBoundingClientRect().height;
      const startConsoleHeight = consolePanel.getBoundingClientRect().height;
      
      document.body.classList.add('resizing-v');
      resizeV.classList.add('dragging');
      
      const onMouseMove = (e) => {
        const delta = e.clientY - startY;
        const totalHeight = startEditorHeight + startConsoleHeight;
        const newEditorHeight = Math.max(100, Math.min(totalHeight - 100, startEditorHeight + delta));
        const newConsoleHeight = totalHeight - newEditorHeight;
        
        editorPanel.style.flex = `0 0 ${newEditorHeight}px`;
        consolePanel.style.flex = `0 0 ${newConsoleHeight}px`;
      };
      
      const onMouseUp = () => {
        document.body.classList.remove('resizing-v');
        resizeV.classList.remove('dragging');
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        if (editor) editor.refresh();
        if (consoleInput) consoleInput.refresh();
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }

  // Vertical resize (variables/plots in session pane)
  if (resizeVSession && variablesSection && plotsSection) {
    resizeVSession.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const startY = e.clientY;
      const startVariablesHeight = variablesSection.getBoundingClientRect().height;
      const startPlotsHeight = plotsSection.getBoundingClientRect().height;
      
      document.body.classList.add('resizing-v');
      resizeVSession.classList.add('dragging');
      
      const onMouseMove = (e) => {
        const delta = e.clientY - startY;
        const totalHeight = startVariablesHeight + startPlotsHeight;
        const newVariablesHeight = Math.max(60, Math.min(totalHeight - 80, startVariablesHeight + delta));
        const newPlotsHeight = totalHeight - newVariablesHeight;
        
        variablesSection.style.flex = `0 0 ${newVariablesHeight}px`;
        plotsSection.style.flex = `0 0 ${newPlotsHeight}px`;
      };
      
      const onMouseUp = () => {
        document.body.classList.remove('resizing-v');
        resizeVSession.classList.remove('dragging');
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }
}

// ===== Event Listeners =====

function initEventListeners() {
  const runBtn = getElement('runBtn');
  const clearConsoleBtn = getElement('clearConsoleBtn');
  const clearHelpBtn = getElement('clearHelpBtn');
  const clearPlotsBtn = getElement('clearPlotsBtn');
  const plotPrev = getElement('plotPrev');
  const plotNext = getElement('plotNext');
  const tabSession = getElement('tabSession');
  const tabHelp = getElement('tabHelp');

  const runLineBtn = getElement('runLineBtn');
  const runScriptBtn = getElement('runScriptBtn');
  if (runLineBtn) runLineBtn.addEventListener('click', runFromEditor);
  if (runScriptBtn) runScriptBtn.addEventListener('click', runScript);
  if (clearConsoleBtn) clearConsoleBtn.addEventListener('click', clearConsole);
  if (clearHelpBtn) clearHelpBtn.addEventListener('click', clearHelp);
  if (clearPlotsBtn) clearPlotsBtn.addEventListener('click', clearPlots);

  // Tab switching
  if (tabSession) tabSession.addEventListener('click', () => switchTab('session'));
  if (tabHelp) tabHelp.addEventListener('click', () => switchTab('help'));

  // Plot navigation
  if (plotPrev) {
    plotPrev.addEventListener('click', () => {
      if (currentPlotIndex > 0) {
        currentPlotIndex--;
        updatePlotDisplay();
      }
    });
  }

  if (plotNext) {
    plotNext.addEventListener('click', () => {
      if (currentPlotIndex < plotImages.length - 1) {
        currentPlotIndex++;
        updatePlotDisplay();
      }
    });
  }

  // Keyboard navigation for plots
  document.addEventListener('keydown', (e) => {
    const inEditor = document.activeElement.closest('.CodeMirror');
    if (inEditor) return;
    
    if (e.key === 'ArrowLeft' && plotImages.length > 0 && currentPlotIndex > 0) {
      currentPlotIndex--;
      updatePlotDisplay();
    } else if (e.key === 'ArrowRight' && plotImages.length > 0 && currentPlotIndex < plotImages.length - 1) {
      currentPlotIndex++;
      updatePlotDisplay();
    }
  });
}

// ===== Initialization =====

function loadCodeFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  return code ? decodeURIComponent(code) : '';
}

function init() {
  console.log('Initializing playground...');
  
  try {
    const initialCode = loadCodeFromUrl();
    initEditor(initialCode);
    initConsoleInput();
    
    if (consoleInput) {
      consoleInput.setOption('readOnly', true);
    }
    
    initResize();
    initEventListeners();
    initWebR();
    
    console.log('Initialization complete');
  } catch (error) {
    console.error('Initialization error:', error);
    setStatus('error', 'Initialization failed');
  }
}

// Start the app
init();
  </script>
</body>
</html>